\documentclass[a4paper,twoside,11pt]{article}
\usepackage{a4wide,graphicx,fancyhdr,amsmath,amssymb,float,longtable}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage{url}
\usepackage[superscript]{cite}
\usepackage{listings}

%----------------------- Macros and Definitions --------------------------

\setlength\headheight{20pt}
\addtolength\topmargin{-10pt}
\addtolength\footskip{20pt}

\newcommand{\N}{\mathbb{N}}
\newcommand{\ch}{\mathcal{CH}}
\everymath{\displaystyle}
\newcommand{\solution}[1]{\noindent{\bf Solution to Exercise #1:}}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyhead[LO,RE]{\sffamily\bfseries\large Technische universiteit Eindhoven}
\fancyhead[RO,LE]{\sffamily\bfseries\large 2IS55 Software Evolution}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO,LE]{\sffamily\bfseries\large Technische universiteit Eindhoven}
\fancyhead[LO,RE]{\sffamily\bfseries\large 2IV35 Visualization}
\fancyfoot[LO,RE]{\sffamily\bfseries\large department of mathematics and computer science}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}


%-------------------------------- Title ----------------------------------

\title{\sffamily\bfseries 2IS55 Software Evolution - Assignment 2}
\author{Mart Pluijmaekers \qquad Student number: 0753117 \\{\tt m.h.l.pluijmaekers@student.tue.nl}}

\date{\today}

%--------------------------------- Text ----------------------------------

\begin{document}
\maketitle
\tableofcontents
\newpage


\section{Introduction}
UML Class diagrams are usually the basis of software development. Using these class diagrams programmers can get a lot of information about the inner workings of the program: the basic structure, ways to divide up the work, etcetera. It is even possible to derive the basis of the code from these diagrams which helps speed up projects. \\

The reverse also applies, going from implementation back to a higher level - in our case the UML diagram - will give a representation of the actual implemented architecture. Since we abstracted from the implementation it is much easier to analyse the architecture, especially when analysing two distinct versions of the code. Since it enables the analysis of the actual evolution of the project. \\

In this paper we will be presenting a method of generating UML class diagrams from Java projects, implemented in the the Rascal\cite{url:rascal} DSL which is suited for software analysis.  We start by describing the input and output required in section \ref{sec:inputoutput}. Section \ref{sec:tooldescription} describes the toolchain itself, how it works and how it should be used. The actual application of the toolchain will be in section \ref{sec:toolapplication} where we will apply it to analyse two different versions of the CyberNeko HTML parser\cite{url:cyberneko}. Lastly,  sections  \ref{sec:discussion} and  \ref{sec:conclusion} will contain the discussion and conclusion respectively.


\section{Input and output}
\label{sec:inputoutput}
In this section we describe the input and output structure of our toolchain. In section \ref{sec:featuresupport} we will state the implemented and unimplemented features of the toolchain and how these are represented in the output (UML diagram).

\subsection{Input}
\label{sec:input}
Since our toolchain operates over a software project we need the location of the sourcefiles. Since we are using Rascal - which works best through the Eclipse IDE\cite{url:eclipse} - we require that the sourcefiles are contained within an Eclipse project. Since we are generating a UML diagram in the form of a dot file - which can be parsed to a large number of document formats (PDF, PNG, etc.) using Graphviz\cite{url:graphviz} - we also need the location of this file as input.

\subsubsection{Feature support}
\label{sec:featuresupport}
We noticed that the sources of the CyberNeko parse contained multiple classes with the same name, but they existed in different packages. Therefor we implemented basic package support, making sure that these classes were displayed seperately. The UML diagram itself does not display these packages however, we wanted to implement this too, but were unable to do this due to time constraints. \\

One of the major language features of java is support for multiple classes in the same file, so called ``inner classes'' which we have filtered out and added to our export too. Generics on the other hand are not implemented, since in our sources we did not find a reference to a generic type. It could however, be implemented quite easily, by changing the function which translates the TypeSet to a human readable string. Everything is in place to add this feature,  adding a loop and a translation to human readable string is everything that needs to added to complete this feature.

\subsection{Output}
\label{sec:output}
The output of the toolchain consists of a dot-file which can be used by Graphviz\ref{url:graphviz} to render a human viewable document in a desired format (PDF, PNG, etc.). We chose the dot format, since it makes the process of building the UML diagram itself much easier, since we can leave the actual rendering to an existing program. Furthermore, the dot file is a plaintext file which makes it very simple to generate programmatically. \\

UML class diagrams consist of tables of 1 column and 3 rows representing a class. The first row in the table contains the classname, the second row all fields of the class, and the third row the methods of the class. As in many programming languages, in Java the methods and fields have visibility modifiers which we have modelled as follows:

\begin{itemize}
\item {\sc Public} as is normal in UML, public fields are modelled with a plus-sign prefixed to the name. 
\item {\sc Private} as is normal in UML, private fields are modelled with a minus-sign prefixed to the name.
\item {\sc Protected} as is normal in UML, protected fields are modelled with a pound-sign prefixed to the name.
\item {\sc Final} as is normal in UML, final fields are modelled by changing the name to uppercase.
\item {\sc Static} normally static fields are modelled by underlining the field. Since this was tough to get to work properly with the dot-format, we chose to model it by adding an underscore as prefix and suffix to the fieldname.
\end{itemize}

We chose not to implement support for named associations since it became apparent that it is very difficult to implement this in such a way that one can reasonably assume that the reverse engineering to be correct. Furthermore, we are interested in the actual implemented architecture instead of the original intent of the designer. Which diminishes the usefulness of named associations.\\

We are however showing multiplicities, although not in a normal matter by displaying them on the edges, but through the field/method definitions. Whenever an array is shown it indicates a larger than one multiplicity while single value fields have a multiplicity of one. \\


\section{Toolchain description}
\label{sec:tooldescription}
aaa

\subsection{Usage}
As stated in the introduction, the tool is built using the DSL Rascal, therefore having a working Rascal installation is required before we can run the toolchain. We make heavy use of the Rascal-OFG\cite{url:rascalofg} library for initially converting the source files to a rascal {\sc Program} which we could use to build the Object Flow Graph. \\

The toolchain itself consists of the two Rascal modules, where {\sc BuildDiagram.rsc} is responsible for the actual building of the UML class diagram, {\sc ObjectFlow.rsc} is responsible for the Object Flow Graph used in {\sc ObjectFlow.rsc}.  We assume for the stated examples that Rascal is run from the Eclipse IDE. \\

There are two ways of generating a dot file from an Eclipse project, one with an automated output to a file, while the other returns the dot string on stdout. \\

\bigskip

{\tt renderProject(|project://<PROJECT NAME>|)}\\
This call will build the class diagram from the source code and output the dot file to stdout. \\

\bigskip

{\tt buildForProject(|project://<PROJECT NAME>|, |file://<DOT FILE LOCATION>|)} \\
%\end{lstlisting}
This call will build the class diagram of the specified project and optionally save it to the specified file location. When the second parameter is not present, the toolkit will store the dot file in the home directory in a file called {\sc classDiagram.dot}\\

From this dot file we can generate the human viewable class diagram using GraphViz using the following command: \\
{\tt dot -T <FILE TYPE> <DOT FILE> -O <DESIRED FILE NAME>}
Where the filetype is one of the \href{http://www.graphviz.org/doc/info/output.html}{many supported file types} by GraphViz. Note that other rendering programs might work too, but this is not guaranteed since we only used GraphViz and it is possible that there are minor inconsistencies in the parsing of the dot file, which produces unexpected results.


\section{Toolchain application}
\label{sec:toolapplication}
aaa



\subsection{eLib}
\label{sec:elib}
aaa

\subsection{CyberNeko}
\label{sec:cyberneko}
aaa

\subsubsection{CyberNeko 0.9.5}
\label{sec:cyberneko095}
aaa

\subsubsection{CyberNeko 1.9.21}
\label{sec:cyberneko1921}
aaa

\subsection{Comparison of the CyberNeko versions}
\label{sec:comparison}
aaa

\section{Discussion}
\label{sec:discussion}
aaa

\section{Conclusion}
\label{sec:conclusion}
aaa

\begin{thebibliography}{9}
\bibitem{url:rascal}
  CWI (2014). Rascal MPL . Available: \url{http://www.rascal-mpl.org/}
\bibitem{url:eclipse}
  The Eclipse Foundation (2015). Eclipse IDE . Available: \url{https://eclipse.org/}
\bibitem{url:graphviz}
 Graphviz. Graphviz - Graph Visualization Software. Available: \url{http://www.graphviz.org/}
\bibitem{url:cyberneko}
 CyberNeko. CyberNeko HTML Parser. Available: \url{http://sourceforge.net/projects/nekohtml/}
\bibitem{url:rascalofg}
 CWI Software Analysis and Transformation. Rascal-OFG. Available: \url{https://github.com/cwi-swat/rascal-OFG}

\end{thebibliography}
\end{document}
